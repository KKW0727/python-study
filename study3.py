#より複雑なデータ型を扱う
#リスト型

# scores = [10, 20, 30, 40, 50] #10, 20, 30などの個々のデータを要素と呼び
#要素は必ずしも同じデータ型である必要はなくて、ここに文字列型や、真偽値などを混ぜてもok
#でもリストは似たようなデータを大量に処理するときによく使われる

# print(scores) #10,20,30,40,50
# scores[1] = 100 # 20を100に変える
# print(scores) #10,100,30,40,50 / 20が100に置き換わってる

# print(scores[0]) #10



#リストに要素を追加
#appendメソッド
#scores = [10, 20, 30, 20, 40]
#scores.append(60) #末尾に一つの要素を追加
#print(scores) #[10, 20, 30, 20, 40, 60]


#末尾に複数の要素を追加
#extendメソッド
# scores.extend([70,80,90])

#extend() は + の演算子で書き換えることもできる
#scores += [70,80,90]　/ scores.extend([70,80,90])と同じ意味
# print(scores) #[10, 20, 30, 20, 40, 60, 70, 80, 90]

#リストでは、+だけでなく*の演算子も使うことができる
#scores *= 3
# print(scores) #要素を 3 回繰り返したリストに書き換えてくれる


#途中に要素を追加
#insertメソッド
# ages = [10, 20, 30, 40]
# ages.insert(2,25) ##インデックスが 2の要素の前に 15を入れてね、という意味
# print(ages) #[10, 20, 25, 30, 40]　/ インデックス2は30だから30の前に入る



#リストから要素を削除する
#scores = [10, 20, 30, 20, 40]
#clear()を使う
#scores.clear() #[] / すべての要素を削除して、空にする

#値を指定して削除したい場合
#scores.remove(20)
# 20 の値が複数あった場合、最初の 1 つだけが削除される

#pop()を使う
#poped_item = scores.pop(2) #インデックスを指定して、要素を削除
#poped_item = scores.pop()#pop()の引数を省略すれば、末尾の要素を指定したことになる。

#del()を使う
#del scores[2] / scores.pop(2)と同じ意味
#でも、削除した要素を取得することができない

#pop()は削除した要素を返してくれる。
#print(poped_item) # 30 / インデックスが 2 であった 30 の要素が削除される

#print(scores)



#リストのデータを集計してみる
# scores = [10, 20, 30, 20, 40]
# # len()は他のデータ型でも使えるので、メソッドではなくて関数の書き方
# print(len(scores)) #5 /要素数
# print(min(scores)) #10 /最小値(さいしょうち)
# print(max(scores)) #40 /最大値(さいだいち)
# print(sum(scores)) #120 / 合計

#特定の値がリストの中にいくつあるかを調べる方法
#countメソッドを使う
# print(scores.count(20)) #2

# #特定の値がどのインデックスの位置にあるかを調べる方法
# #indexメソッドを使う
# print(scores.index(20)) #1

# #特定の値がそのリストに存在するかを調べる方法
# #inを使う
# print(30 in scores) #True / inは真偽値を返す
# print(90 in scores) #False



 #リストの要素を並び替える
scores = [10, 20, 30, 20, 40]

##要素の並び順を逆にしてくれる。
#scores.reverse() / 破壊的(元データを直接変更する)

#scores.sort() #値の小さい順に並び替えてくれる。

#値が大きい順に並び替えたい場合
#scores.sort(reverse=True) # sort()に引数を与える


#元データを残しておきたい場合
#元データはそのまま、要素を並び替えた結果を新しいリストとして返してくれるバージョンもある
scores_sorted = sorted(scores, reverse=True) ##非破壊的(元データを破壊しない処理)
print(scores) #[10, 20, 30, 20, 40] / 元データはそのまま
print(scores_sorted)


